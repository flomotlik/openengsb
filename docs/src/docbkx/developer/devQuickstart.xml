<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!--

   Copyright 2010 OpenEngSB Division, Vienna University of Technology

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.

-->
<chapter id="devQuickstart" xmlns="http://docbook.org/ns/docbook">
  <title>Getting Started as a Developer</title>
  <para>
    This chapter gives an overview how to quickly start with the OpenEngSB.
  </para>
  <section id="devQickstart.pre">
    <title>Prerequisites</title>
    <para>
      First of all the JDK 6 has to be installed on the system and the <envar>JAVA_HOME</envar> variable has to be set accordingly.
      All further steps are described in the subsections of this chapter.
    </para>
    <section id="devQickstart.pre.git">
      <title>Installing Git</title>
      <para>
        Further more its assumed that Git had been installed. For Git we recommend the latest Cygwin with the Git
        packages. Please set at least the following variables:
      </para>
      <literallayout><command>git config</command> <option>--global</option> user.name "<replaceable>Firstname Lastname</replaceable>"
<command>git config</command> <option>--global</option> user.email <replaceable>user@example.com</replaceable>
<command>git config</command> <option>--global</option> core.autcrlf input</literallayout>
    </section>
    <section id="devQickstart.pre.maven">
      <title>Installing Maven</title>
      <para>
        Finally download Apache Maven and unpack it. Add the path of the maven binary to your PATH variable. Further more
        you should set the <envar>MAVEN_OPTS</envar> environment variable to allow Maven to use more RAM. If you don't you'll get
        Out Of Memory errors.
        <literallayout><command>export</command> <envar>PATH</envar>=$<envar>PATH</envar>:<replaceable>/path/to/maven</replaceable>/bin
<command>export</command> <envar>MAVEN_OPTS</envar>='-Xmx1024M -XX:MaxPermSize=512m'</literallayout>
      Add these commands to <filename>~/.bashrc</filename> to make the settings permanent.
      </para>
    </section>
    <section id="devQickstart.pre.smx">
      <title>Installing Servicemix</title>
      <para>
        Download the latest version of Apache Servicemix from <ulink url="http://servicemix.apache.org/" />.
        After unpacking it you can start it by executing <code>bin/servicemix</code>.
      </para>
    </section>
  </section>
  <section id="devQickstart.essential">
    <title>Starting OpenEngSB</title>
    <para>
      The next step is to get the OpenEngSB source by checking out the current master using git:
      <literallayout><command>git clone</command> git://github.com/openengsb/openengsb</literallayout>
      Now start Servicemix with the scripts in <filename>servicemix/bin/</filename>.
      Finally build and deploy the OpenEngSB to Servicemix:
      <literallayout><command>etc/scripts/quickrun.sh</command></literallayout>
    </para>
  </section>
  <section id="devQickstart.eclipse">
    <title>Using Eclipse</title>
    <para>
      Eclipse had been chosen by the OpenEngSB team as the main development environment. After checkout the code the
      following command creates the required Eclipse project files:
    </para>
    <literallayout><command>mvn</command> eclipse:configure-workspace
<command>mvn</command> eclipse:eclipse</literallayout>
    <para>
      Start Eclipse and select <guimenu>File</guimenu>, <guimenu>Select Workspace</guimenu>,
      <guimenu>Other...</guimenu> and choose the
      <filename>eclipse-workspace</filename> directory. This is a subdirectory of the OpenEngSB source.
      After Eclipse restarted you can import the projects:
      <guimenu>File</guimenu>, <guimenu>Import...</guimenu>, <guilabel>Existing Projects into Workspace</guilabel>.
      As the root directory select
      the root of the OpenEngSB source. Eclipse will list several projects and for now it's best to import
      them all by clicking <guibutton>Finish</guibutton>.
    </para>
  </section>
  <section id="devQickstart.structure">
    <title>Directory Structure</title>
    <para>
      This section describes the directory structure of OpenEngSB. Since this project contains a huge amount of
      projects they are divided into a hierarchy. Namely there are three parts in the directory structure
      which should be explained step by step. The name of the projects is always generated by the directory
      hierarchy. For example a project nested in <filename>features/edb/core</filename> would 
      be named <code>openengsb-features-edb-core</code>.
    </para>
    <para>
      The following structure shows the core projects for OpenEngSB. If a new project is created which es a part of
      the core of the OpenEngSB and which could not be separated at all it would create a new subdirectory in this tree.
      Because of the JBI project structure it is required that more than one project is nested in each subnode (at least
      service-unit and service-engine).
    </para>
    <literallayout><filename>openengsb</filename>
<filename>openengsb/ekb</filename>
<filename>openengsb/config</filename>
<filename>openengsb/context</filename>
<filename>openengsb/package</filename>
<filename>openengsb/core</filename>
<filename>openengsb/workflow</filename>
<filename>openengsb/workflow/drools</filename>
<filename>openengsb/workflow/bpel</filename>
<filename>openengsb/testing</filename></literallayout>
    <para>
      Beside of the core packages there are additional packages extending the OpenEngSB with additional features and
      therefore stored in a feature subdirectory. These projects could not exist without the OpenEngSB but the OpenEngSB
      could exist without them. They are designed to fulfill a specific purpose to extend the functionality of the OpenEngSB,
      but may not be interesting for most users. For this reason the folder is nested in a deeper structure.
      Features as the "edb" or "link" could be found here.
    </para>
    <literallayout><filename>openengsb</filename>
<filename>openengsb/features</filename>
<filename>openengsb/features/edb</filename>
<filename>openengsb/features/link</filename></literallayout>
    <para>
      The last part of the file structure contains the core packages for the OpenEngSB; its domains and connectors. As
      will be explained later in more detail the OpenEngSB integrates tools differently than a "regular" enterprise
      service bus. An enterprise service bus directly integrates tools, where the OpenEngSB adds an additional abstraction
      layer via domains. This structure is also shown in the directory hierarchy. Domains are stored in a separate subdirectory,
      since they are to be separated into subprojects in the future.
    </para>
    <para>
      Each domain could be found in the <code>openengsb/domains</code> directory. Domains cover mostly one huge part in the engineering
      domain as SCM, Notification, Issues and so on. Therefore for each of these parts an additional subfolder had been
      created. The domain itself could be found in the
      <code>openengsb/domains/<emphasis>Domain</emphasis>/implementation</code> subdirectory of a domain. This folder will
      always contain at least a service-engine or a binding-unit and a service-unit. The service-engine or binding-unit
      are required to implement the domain logic at all where the service-unit is required to configure the domain. Domains
      are always configured only once in one OpenEngSB instance which explains why they are defined directly in the project.
    </para>
    <para>
      Beside the domains the real tool implementations could be found. For the notification domain useful implementations
      are, as shown, the Email and Jabber implementations which allows to send notifications via Jabber or Email. Regulary
      the service-engine is implemented, in this case directly in the root folder (.../email or .../jabber) since the service-unit
      is created at runtime for such components.
    </para>
    <para>
      The last interesting part in the domain directory is <code>openengsb/domains/toolAbstraction</code>. This directory contains
      projects which "generally abstract" tools to a higher and better usable level and if its required to use this
      abstraction layer above several domain-tool-connectors. For example the additionally required infrastructure for the
      SVN connector would not make any sense in the additional tool abstraction layer since it is only required once for
      implementing the SVN connector for the SCM domain. But compared to that Maven could be used for more than one
      tool-domain. Maven could be used at least for Build, Test and Deploy. Therefore there would be duplicated code
      to abstract the tool to the needs of the connectors. The toolAbstraction folder is the right place for additional
      abstractions required for use cases as described with the Maven project.
    </para>
    <literallayout><filename>openengsb</filename>
<filename>openengsb/domains</filename>
<filename>openengsb/domains/toolAbstraction</filename>
<filename>openengsb/domains/notification</filename>
<filename>openengsb/domains/notification/implementation</filename>
<filename>openengsb/domains/notification/email</filename>
<filename>openengsb/domains/notification/jabber</filename>
<filename>openengsb/domains/scm</filename></literallayout>
    <para>
      Since the number of projects increases steadily it is required to fit all projects
      into this structure so it's maintainable.
    </para>
  </section>
  <section id="devQickstart.assembly">
    <title>Assembling OpenEngSB</title>
  <section id="devQickstart.assembly.introduction">
    <title>Introduction</title>
    <para> This section gives a short overview about the assembly procedure of OpenEngSB. Furthermore a short
      description of the structure of the assembled project is given.
  </para>
  </section>
  <section id="devQickstart.assembly.howto">
    <title>How to assemble OpenEngSB</title>
    <para>
      To create a distributable form of OpenEngSB simply run <code>scripts/assemble.sh</code>.
      Two zip files are created in the target folder of the project root. The structure of the zips is explained in the following section.
      The zip files are called <code>openengsb-<emphasis>version</emphasis>-windows.zip</code> and
      <code>openengsb-<emphasis>version</emphasis>-unix.zip.</code> After
      unzipping the assembly Servicemix can be started using the openengsb executable
      in the <code>apache-servicemix-<emphasis>version</emphasis>/bin/</code> directory. The OpenEngSB
      components are already included in the hotdeploy directory of Servicemix and will be started automatically on Servicemix startup.
    </para>
  </section>
  <section id="devQickstart.assembly.structure">
    <title>Structure</title>
    <para>
      <literallayout>        openengsb-{version}
        |
        |- docs
        |    |
        |    |- html
        |    |- pdf
        |
        |- servicemix
        |    |
        |    |
        |    |- deploy (openengsb components)
        |    |- bin (executable to start servicemix - openengsb.bat or openengsb.sh)
        |
        |- README
        |- LICENSE
        |- NOTICE</literallayout>
    </para>
  </section>
  </section>
  <section id="git">
    <title>Git Documentation</title>
    <section>
        <title>Usage</title>
        <para>
        First of all this chapter explains only the <emphasis>very</emphasis> basics of Git and only that parts directly relevant for the
        development of the OpenEngSB project, but not the entire idea and possibilities of Git.
        <emphasis>Please</emphasis> read some
        tutorials first to get how to work with Git and see this chapter more as an summary! You may also take a look
        at the <ulink url="http://git-scm.com/documentation/">Git Documentation Page</ulink> and the
        <ulink url="http://progit.org/book/">Pro Git Book</ulink>.
        </para>
    </section>
    <section>
      <title>Remarks</title>
      <para>
        If you are using Windows then the best way to work with Git is using
        <ulink url="http://www.cygwin.com/">Cygwin</ulink>. The packages openssh, git and gitk are required.
      </para>
    </section>
    <section>
      <title>Github</title>
      <para>OpenEngSB is developed at
        <ulink url="http://github.com/">github.com</ulink>. Please create an account there and explore its features.
        Specify your real name in the admin tab and add a picture. This makes it easier to associate your commits to you.
      </para>
    </section>
    <section>
      <title>Starting up and configure</title>
      <para>
      Before starting to work with Git some settings should be applied to Git. Therefore simply execute the following
 commands.

  <literallayout><command>git config</command> <option>--global</option> user.name "<replaceable>Firstname Lastname</replaceable>"
<command>git config</command> <option>--global</option> user.email <replaceable>user@example.com</replaceable>
<command>git config</command> <option>--global</option> color.ui "auto"
<command>git config</command> <option>--global</option> pack.threads "0"
<command>git config</command> <option>--global</option> diff.renamelimit "0"
<command>git config</command> <option>--global</option> core.autocrlf "input"</literallayout>

  Additionally execute the special settings for github as could be found on github in the "Account Settings"
 tab is a point "Global git config information". Please use the two git commands described there

  <literallayout><command>git config</command> <option>--global</option> github.user <replaceable>username</replaceable>
<command>git config</command> <option>--global</option> github.token <replaceable>token</replaceable></literallayout>

 If you don't already have an SSH key you can create one by executing <userinput>ssh-keygen</userinput>

  Simply answer all questions from the application with "enter" without enter any values. Afterwards the content of the
  <filename>id_rsa.pub</filename> file from your <filename>~/.ssh/</filename> directory
  should be submitted to github (<guilabel>Account Settings</guilabel>/<guilabel>SSH public keys</guilabel>).
    </para>
    </section>
    
    
    <section>
        <title>Contributor Workflow</title>
        <para>
        Contributor are all developer who like to contribute to the OpenEngSB project, but not have commit rights to the
 master. Nevertheless the same workflow is also valid for commiter with the difference that they have additional
 responsibilities.
        </para>
        <section>
            <title>Initial Setup</title>
            <para>
              Create a fork from <ulink url="http://github.com/openengsb/openengsb/">the OpenEngSB repository at github</ulink>.
              Click on the button <emphasis>Fork</emphasis> and follow the instructions there.
              
              Now clone the original repo:
              <literallayout><command>git clone</command> git://github.com/openengsb/openengsb</literallayout>
              If you are a committer with write access this would be:
              <literallayout><command>git clone</command> git@github.com:openengsb/openengsb</literallayout>
              
              Add your fork as remote branch:
              <literallayout><command>git remote</command> add <replaceable>username</replaceable> git@github.com:<replaceable>username</replaceable>/openengsb</literallayout>
              Example: <literallayout><command>git remote</command> add ChristophGr git@github.com/ChristophGr/openengsb</literallayout>
            </para>
        </section>
        <section>
            <title>Creating a new Branch for a feature</title>
            <para>
              It's always a good idea to synchronize your local Git repository with all the external repositories.
              This is done by executing:
              <literallayout><command>git remote</command> update -p</literallayout>
              
              Now create your branch:
              <literallayout><command>git checkout</command> <option>-b</option> <emphasis>branchname</emphasis> origin/master</literallayout>
              
              Push the new branch to your fork:

              <literallayout><command>git push</command> <replaceable>username</replaceable> <replaceable>branchname</replaceable></literallayout>

              Go to the admin page of your fork and set the default branch to <replaceable>branchname</replaceable>

              Create a new development branch:

              <literallayout><command>git checkout</command> <option>-b</option> devbranch <replaceable>branchname</replaceable></literallayout>
            </para>
        </section>
        <section>
            <title>Working With Your Branch</title>
            <para>
              Start coding and commit your changes to the devbranch. Please make small commits and write meaningful
              commit messages.
            </para>
        </section>
        <section>
            <title>Publishing Your Work</title>
            <para>
              Update your local feature branch by changing from devbranch to MYFEATURE:
              <literallayout><command>git checkout</command> MYFEATURE</literallayout>

              Synchronize your feature with your remote repository:
              <literallayout><command>git pull</command> <replaceable>username</replaceable> <replaceable>branchname</replaceable></literallayout>

              Rebase your devbranch with your feature branch:
              <literallayout><command>git rebase</command> <replaceable>branchname</replaceable> devbranch</literallayout>

              Go back to the feature branch:
              <literallayout><command>git checkout</command> <replaceable>branchname</replaceable></literallayout>

              Merge your devbranch into the feature branch
              <literallayout><command>git merge</command> devbranch</literallayout>

              Push the changes:
              <literallayout><command>git push</command> <replaceable>username</replaceable> <replaceable>branchname</replaceable></literallayout>

              If you want to continue working on this branch then check it out:
              <literallayout><command>git checkout</command> devbranch</literallayout>
            </para>
        </section>
        <section>
            <title>Long-Time Development Features</title>
            <para>
            If the development in the branch takes some time, it may happen, that the master-branch changes in a way that
            affects your featurebranch. To check how your branch behaves on the current master you can merge the changes into your devbranch.

            <literallayout><command>git checkout</command> <replaceable>branchname</replaceable>
<command>git merge</command> <option>--no-commit</option> <option>--no-ff</option> origin/master</literallayout>
  
            If it does not affect your development in any way, do not commit the merge, but rather undo it.

            <literallayout><command>git reset</command> <option>--hard</option></literallayout>

            If it does affect your development, you need to commit the merge. If the merge breaks something in your devbranch, fix all
            issues before commiting the merge.  When done fixing potential issues do

            <literallayout><command>git commit</command></literallayout>
            </para>
        </section>
        <section>
            <title>Finish Feature</title>
            <para>
              If you think you are finished with your feature please post to the OpenEngSB developer list.
              A committer will decide if he will merge your branch or give you feedback.
            </para>
        </section>
    </section>
    <section>
        <title>Commiter Workflow</title>
        <para>
          The only difference between a committer and a contributor is that he has to watch and merge branches of
          contributors. If a commiter is happy with the work of a contributor. Comments and other discussions should be
          done on the mailing list and/or via the github review system. Committers should always watch the branches
          and forks of contributors to review, comment and give feedback as soon as possible.
        </para>

        <para>
          To merge a branch of a contributor the following steps has to be done. The following preconditions are relevant:
          <orderedlist>
            <listitem>You want to merge a feature MYFEATURE</listitem>
            <listitem>from a user USERNAME</listitem>
            <listitem>and openengsb/openengsb repository is your origin repository.</listitem>
          </orderedlist>


          First of all you have to add the user's fork as a remote repository
          <literallayout><command>git remote</command> add USERNAME git://github.com/USERNAME/openengsb</literallayout>

          Now update the remote repository
          <literallayout><command>git remote</command> update -p</literallayout>

          Checkout the origin master
          <literallayout><command>git checkout</command> -b master origin/master</literallayout>

          Merge the feature branch
          <literallayout><command>git merge</command> USERNAME/MYFEATURE --no-ff</literallayout>

          Push the changes to the master
          <literallayout><command>git push</command> origin master</literallayout>
        </para>
    </section>
    <section>
        <title>Additional Rules</title>
        <para>
          <orderedlist>
            <listitem>
              (Contributor/Committer)
              All development is done in forks (also of the core developers)
              One exception to this rule exists: Small fixes and maintenance work which is NOT related to a new feature and does not exceed 2 commits should be rebased and merged (or cherry-picked) into the master directly.         
            </listitem>
            
            <listitem>
              (Contributor/Committer)
              Rebase is <emphasis>not</emphasis> dead (although we use merges). <emphasis>Never ever</emphasis> commit local
              merges. You still have to develop in local dev branches and rebasing them
              with the upstream branches. Only if nobody else has access to your fork you
              can be sure that nobody changed it!
            </listitem>
            
            <listitem>
              (Committer)
              Merges to the master have to be done from the upstream branches not the
              local ones! This means if you want to merge the branch test from the fork
              eyeball into the master do NOT use
            
              <literallayout><command>git checkout</command> test eyeball/test
<command>git checkout</command> master
<command>git merge</command> test</literallayout>

              but rather
              <literallayout><command>git checkout</command> master
<command>git merge</command> eyeball/test
</literallayout>

              This will create much better readable merge nodes.
            </listitem>

            <listitem>
              (Committer)
              If merging branches from forked repositories ALWAYS use the <option>--no-ff</option> option
              for merges; this will always create a merge node (even if a fast-forward
              merge is possible). This is required to create a clear and consistent
              history!
            </listitem>
            
            <listitem>
              Avoid backward merges from the master and keep feature branches small!
              This does not mean that backward merges from master are forbidden. But they should
              not be done too often, since they create a history not easy to read. Please use
              the method described on this page (with <option>--no-ff</option> <option>--no-commit</option>) to reduce the number
              of merge nodes.
            </listitem>

            <listitem>
              Use <emphasis>meaningful</emphasis> feature branch names. Using the merge history in the master
              you can easily follow the development of features. But this requires (maybe
              long) good names!
            </listitem>
            
            <listitem>
              Keep your forks clean. Although git can handle thousands of branches in
              thousands of forks we (as committers) can't. Having all the forks as remote
              repositories makes it really hard for us to handle all the branches in all
              the forks. Therefore please remove <emphasis>all</emphasis> branches already merged or not
              required. Also remove your forked master and the already existing branches.
              You can remove your local master by changing in the admin page of your fork
              the default branch to your current branch; if master is no longer the
              default branch you can kick it. Additionally it's nevertheless better to use
              the remote master instead of your forked to kick off your dev branches.
            </listitem>
          </orderedlist>
        </para>
    </section>
    </section>
</chapter>
